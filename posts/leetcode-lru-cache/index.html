<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.62.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Implement LRU Cache&nbsp;&ndash;&nbsp;Untitled Thoughts</title><link rel="stylesheet" href="/css/core.min.8c24852e5f6a6bd910400b8fbb878613fcb4debd54b64e9c0e3309c16ff60dd7c9fb88e29ad2fbefeb14054f849ce8ad.css" integrity="sha384-jCSFLl9qa9kQQAuPu4eGE/y03r1Utk6cDjMJwW/2DdfJ&#43;4jimtL77&#43;sUBU&#43;EnOit"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Implement LRU Cache" />

<link rel="shortcut icon" type="image/x-icon" href="https://ryanym.com/favicon.ico">
<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Untitled Thoughts</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/coursework">Coursework</a><a class="nav item" href="/bookshelf/">Bookshelf</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Implement LRU Cache</h1><p class="article date">Thursday, February 27, 2020</p></section><article class="article markdown-body"><p>Problem: <a href="https://leetcode.com/problems/lru-cache/"target="_blank">146. LRU Cache</a></p>
<blockquote>
<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU"target="_blank">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>
<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong>
Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<pre><code>LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre></blockquote>
<h3 id="intuition">Intuition</h3>
<p>Looking at the requirements, we know that we need couple things to build this LRU cache:</p>
<ul>
<li>Something to hold the cache</li>
<li>Something to keep track the least recently used items and evict them when reaching capacity</li>
</ul>
<h3 id="attempt-1-failed">Attempt #1 [Failed]</h3>
<p>For holding key and value it's pretty obvious we could use a hashmap to achieve the O(1) get and put. However, a regular hashmap doesn't not have order or priority, which means we cannot keep track the least used items without introducing another attribute to represent when this item was last created or accessed.</p>
<h4 id="how-to-keep-track-of-the-least-used-items">How to keep track of the least used items?</h4>
<p>First thing came to my mind is to use an integer to represent the least used items, with 0 as the most recently used item To keep track of last used rank, we put 0 as least recently used rank for new item and  increment the rank by 1 for the rest of items to increase their ranks. When an item's rank exeeds the capacity, we remove it from the hashmap.</p>
<p>One obvious mistake in this solution is that we didn't account what to do with get or update operations. And there is no obvious way to recreate the rankings without some kind of sorting which is O(n*log(n)) time.</p>
<h3 id="attempt-2-succeed">Attempt #2 [Succeed]</h3>
<p>In the previous attempt we tried to order these hashmap items by creating an additional attribute to the item but couldn't find an easy way to order them by access time.  What if instead of creating additional attributes, we could find a data structure that both supports ordering, and map-like key value lookup. After some <a href="https://stackoverflow.com/a/663388"target="_blank">googling</a> we found that <code>LinkedHashMap</code> and  <code>SortedMap</code> are good candidates to solve our problem.</p>
<h4 id="which-one-should-we-use">Which one should we use?</h4>
<p>For <code>SortedMap</code> we still need to create an additional attribute to represent the least recently used rank, on top of that, each get and put now needs O(log(n)) time to complete.</p>
<p><code>LinkedHashMap</code> maintains a natural ordering as items are added to the map, and, it has a nice method called <code>removeEldestEnrty</code> to help us evict the least used items. Let's take a deeper look at this class:</p>
<blockquote>
<h3 id="linkedhashmap">LinkedHashMap</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span>
                     <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">,</span>
                     <span class="kt">boolean</span> <span class="n">accessOrder</span><span class="o">)</span>
</code></pre></div><p>Constructs an empty LinkedHashMap instance with the specified initial capacity, load factor and ordering mode.
Parameters:
initialCapacity - the initial capacity
loadFactor - the load factor
accessOrder - the ordering mode - true for access-order, false for insertion-order
Throws:
IllegalArgumentException - if the initial capacity is negative or the load factor is nonpositive</p>
<h3 id="heading"></h3>
</blockquote>
<p>We can see that <code>LinkedHashMap</code> even allows us to order by access order, which is exactly we need. Now let's take a look at the method <code>removeEldestEntry</code> and how we can use it to evict the least used item when exceeding capacity:</p>
<blockquote>
<p>removeEldestEntry</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span>
</code></pre></div><p>Returns <code>true</code> if this map should remove its eldest entry. This method is invoked by <code>put</code> and <code>putAll</code> after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries.</p>
<p>Sample use: this override will allow the map to grow up to 100 entries and then delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_ENTRIES</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>

     <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">MAX_ENTRIES</span><span class="o">;</span>
     <span class="o">}</span>
</code></pre></div></blockquote>
<h4 id="put-linkedhashmap-into-action">Put <code>LinkedHashMap</code> into action</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// initialize linked hashmap ordered by access time, 0.75F is the load factor
</span><span class="c1"></span>        <span class="kd">super</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span><span class="n">0</span><span class="o">.</span><span class="na">75F</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span><span class="o">;</span>
        <span class="n">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span><span class="o">)</span><span class="o">{</span>
        <span class="c1">// evict least used item when cache size is greater than capacity, note this method is invoked by put()
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="attempt-3-works-but-slow">Attempt #3 [Works, but slow]</h3>
<p><code>LinkedHashMap</code> is great, but what if you never used it before or weren't allowed to google during an interview? Well we know we need some list to maintain the order of the cache, and we need to constantly moving elements in the front of the list and popping item at the end of the list. With this in mind, we can build a simple (but inefficient) LRU cache with list and tuple: we store key and value in the tuple and insert (or remove) these tuples to the list as we add (or evict) items.</p>
<p>Each put() and get() takes O(n) time because it involes searching the entire list to locate the item and to shift items around for add() and remove() calls.</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// initialize linked hashmap ordered by access time, 0.75F is the load factor
</span><span class="c1"></span>        <span class="n">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
               <span class="c1">// we remove current tuple from the list and insert it in the front of list
</span><span class="c1"></span>               <span class="n">Tuple</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">.</span><span class="na">y</span><span class="o">)</span><span class="o">;</span>
               <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">;</span>
               <span class="n">cache</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span><span class="o">;</span>
               <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
           <span class="o">}</span>
       <span class="o">}</span>

       <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// check if key exists in cache, update tuple by removing and inserting new tuple in the front
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Tuple</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">;</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">Tuple</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tuple</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="n">Integer</span> <span class="n">x</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="n">Integer</span> <span class="n">y</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Tuple</span><span class="o">(</span><span class="n">Integer</span> <span class="n">x</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="attempt-4-works-but-not-what-we-wanted">Attempt #4 [Works, but not what we wanted]</h3>
<p>How do we achieve O(1) read and write while maintaining access order? A map can be used to achieve O(1) lookup, however, from the previous attempts we know we need to rearrange the items each time we do put() or get(). This implies list is out of the picture since add(i, item) and remove(i) is O(n).</p>
<h4 id="which-data-structure-maintains-order-and-has-o1-add-and-remove">Which data structure maintains order and has O(1) add and remove?</h4>
<p>Answer is LinkedList, to be more specific, Doublely LinkedList since we only need reference of the node itself for removal. Let's implement this.</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">lruOrder</span><span class="o">;</span>
    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">lruOrder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">)</span><span class="o">{</span>
           <span class="n">Tuple</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
           <span class="n">lruOrder</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">data</span><span class="o">)</span><span class="o">;</span>
           <span class="n">lruOrder</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">data</span><span class="o">)</span><span class="o">;</span>
           <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
       <span class="o">}</span>
       <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">)</span><span class="o">{</span>
            <span class="n">Tuple</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
            <span class="n">lruOrder</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">data</span><span class="o">)</span><span class="o">;</span>
            <span class="n">Tuple</span> <span class="n">newData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
            <span class="n">lruOrder</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">newData</span><span class="o">)</span><span class="o">;</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newData</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">Tuple</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
            <span class="n">lruOrder</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">data</span><span class="o">)</span><span class="o">;</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lruOrder</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Tuple</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">lruOrder</span><span class="o">.</span><span class="na">removeLast</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">toRemove</span><span class="o">.</span><span class="na">x</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tuple</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="n">Integer</span> <span class="n">x</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="n">Integer</span> <span class="n">y</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Tuple</span><span class="o">(</span><span class="n">Integer</span> <span class="n">x</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Superisingly this is only slightly faster then our attempt #3 which is O(n) time, which meas somethings is not O(1). Upon examining the LinkedList APIs, I found that <code>remove(Object o)</code> actully was in O(n) time since according to the documentation, it removes the <strong>first</strong> <strong>occurrence</strong> of the specified element from this list, if it is present.</p>
<h3 id="attempt-5-succeeded-finally-o1-time">Attempt #5 [succeeded, finally O(1) time]</h3>
<p>We know the problem is the implemenation of  collection's LinkedList remove() method. So&hellip; why not implementing the doubly LinkedList ourselves? LinkedList is a simple concept and our custom doubly linkedlist only needs to achieve the following:</p>
<ul>
<li>maintains order (i.e an ordered list)</li>
<li>addFirst() in O(1) time</li>
<li>remove(Node node) in O(1) time</li>
<li>size() in O(1) time</li>
</ul>
<p>Note that we are constantly inserting to the front of the linkedlist and removing at the end of the linkedlist, it's better to define a dummy head and a dummy tail to make the implementation easier.</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">   <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">;</span>
   <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
   <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
   <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>
   <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
   <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
       <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

       <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
       <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
       <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
       <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
       <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
   <span class="o">}</span>
   
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span> <span class="c1">// previous pointer
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">next</span><span class="o">;</span> <span class="c1">// next pointer
</span><span class="c1"></span>        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="o">)</span><span class="o">{</span><span class="o">}</span>
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// inserting new node after dummy head 
</span><span class="c1"></span>        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        
        <span class="c1">// change dummy head next pointer and original head previous pointer
</span><span class="c1"></span>        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">+</span><span class="o">+</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// get previous and next node of current node
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">prevNode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">nextNode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        
        <span class="c1">// link previous node and next node directly 
</span><span class="c1"></span>        <span class="n">prevNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">nextNode</span><span class="o">;</span>
        <span class="n">nextNode</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prevNode</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">-</span><span class="o">-</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div><p>Add get() and put():</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">)</span><span class="o">{</span>
           <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
           <span class="n">remove</span><span class="o">(</span><span class="n">node</span><span class="o">)</span><span class="o">;</span>
           <span class="n">addFirst</span><span class="o">(</span><span class="n">node</span><span class="o">)</span><span class="o">;</span>
           <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
       <span class="o">}</span>
       <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">)</span><span class="o">{</span>
            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
            <span class="n">remove</span><span class="o">(</span><span class="n">node</span><span class="o">)</span><span class="o">;</span>
            <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
            <span class="n">addFirst</span><span class="o">(</span><span class="n">newNode</span><span class="o">)</span><span class="o">;</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
            <span class="n">addFirst</span><span class="o">(</span><span class="n">newNode</span><span class="o">)</span><span class="o">;</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// using previous of tail to get the last node
</span><span class="c1"></span>                <span class="n">Node</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
                <span class="n">remove</span><span class="o">(</span><span class="n">toRemove</span><span class="o">)</span><span class="o">;</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">toRemove</span><span class="o">.</span><span class="na">key</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p>Finally we have implemented a LRU cache that performs in O(1) time and uses O(n) space where n is the capacity of the cache. By breaking down the requirements, we successfully improved our O(n) implementation to O(1) and we even implemented a doubly linkedlist along the way.</p>
</article><section class="article labels"><a class="category" href=/categories/leetcode/>leetcode</a><a class="category" href=/categories/interview-prep/>interview prep</a><a class="tag" href=/tags/linkedlist/>linkedlist</a><a class="tag" href=/tags/hashmap/>hashmap</a></section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/leetcode-binary-tree/"><span class="li iconfont icon-article"></span>Binary Tree Interview Questions</a></p><p><a class="link" href="/posts/hadoop-multi-namespaces/"><span class="li iconfont icon-article"></span>Accessing mutiple Hadoop amespaces with native HDFS client</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Ryan Ma</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script><script src="/js/prism.min.28f2bfd6dfaa7ad0e8b973373bb7db234d27a2faafc26d5ffd2de4c2b1b5f2bf80011f2e2976dc9fb364abb13f63ebdc.js" integrity="sha384-KPK/1t&#43;qetDouXM3O7fbI00novqvwm1f/S3kwrG18r&#43;AAR8uKXbcn7Nkq7E/Y&#43;vc"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-73966605-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>

</html>